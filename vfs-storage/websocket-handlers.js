// WebSocket Real-time Update Handlers
// Generated by SOUNDBOARD_WEBSOCKET

// Enhanced handleMessage function for app.js
const enhancedHandleMessage = (event) => {
  const data = JSON.parse(event.data);
  
  switch(data.type) {
    // Phase Transitions
    case 'phase-transition':
      handlePhaseTransition(data);
      break;
      
    // Agent Progress Updates
    case 'agent-progress':
      handleAgentProgress(data);
      break;
      
    // VFS Changes
    case 'vfs-update':
      handleVFSUpdate(data);
      break;
      
    // Task Queue Updates
    case 'task-update':
      handleTaskUpdate(data);
      break;
      
    // Component Mount Events
    case 'component-mounted':
      handleComponentMount(data);
      break;
      
    // Error Events
    case 'error':
      handleError(data);
      break;
      
    default:
      console.log('Unknown message type:', data.type);
  }
};

// Phase Transition Handler
function handlePhaseTransition(data) {
  const { fromPhase, toPhase, timestamp } = data;
  
  // Update UI phase indicator
  document.querySelectorAll('.phase-nav-item').forEach(item => {
    item.classList.remove('active');
    if (item.dataset.phase === toPhase) {
      item.classList.add('active');
    }
  });
  
  // Trigger phase transition animation
  const phaseContainer = document.getElementById('phase-container');
  phaseContainer.classList.add('phase-transitioning');
  
  // Log transition
  console.log(`Phase transition: ${fromPhase} â†’ ${toPhase} at ${timestamp}`);
  
  // Broadcast phase change event
  window.dispatchEvent(new CustomEvent('phaseChanged', { 
    detail: { fromPhase, toPhase, timestamp } 
  }));
}

// Agent Progress Handler
function handleAgentProgress(data) {
  const { agentId, taskId, progress, status, message } = data;
  
  // Update progress indicator
  const progressBar = document.querySelector(`[data-agent="${agentId}"] .progress-bar`);
  if (progressBar) {
    progressBar.style.setProperty('--progress', `${progress}%`);
  }
  
  // Update status text
  const statusEl = document.querySelector(`[data-agent="${agentId}"] .status`);
  if (statusEl) {
    statusEl.textContent = status;
    statusEl.className = `status status-${status}`;
  }
  
  // Show message in activity log
  addActivityLog({
    type: 'agent-progress',
    agentId,
    taskId,
    message,
    timestamp: new Date().toISOString()
  });
}

// VFS Update Handler
function handleVFSUpdate(data) {
  const { operation, path, content, timestamp } = data;
  
  switch(operation) {
    case 'create':
      console.log(`VFS: Created ${path}`);
      refreshVFSTree();
      break;
      
    case 'update':
      console.log(`VFS: Updated ${path}`);
      if (isComponentFile(path)) {
        reloadComponent(path);
      }
      break;
      
    case 'delete':
      console.log(`VFS: Deleted ${path}`);
      refreshVFSTree();
      break;
  }
  
  // Update last sync timestamp
  updateLastSync(timestamp);
}

// Task Update Handler
function handleTaskUpdate(data) {
  const { taskId, status, claimedBy, result } = data;
  
  // Update task card
  const taskCard = document.querySelector(`[data-task="${taskId}"]`);
  if (taskCard) {
    taskCard.classList.remove('pending', 'claimed', 'completed');
    taskCard.classList.add(status);
    
    if (claimedBy) {
      taskCard.querySelector('.claimed-by').textContent = claimedBy;
    }
    
    if (result) {
      taskCard.querySelector('.result').textContent = result;
    }
  }
  
  // Update task counter
  updateTaskCounters();
}

// Component Mount Handler
function handleComponentMount(data) {
  const { componentName, containerId, success, error } = data;
  
  if (success) {
    console.log(`Component ${componentName} mounted to ${containerId}`);
    
    // Apply mount animation
    const container = document.getElementById(containerId);
    if (container) {
      container.classList.add('component-mount');
    }
  } else {
    console.error(`Failed to mount ${componentName}:`, error);
    showErrorNotification(`Component mount failed: ${componentName}`);
  }
}

// Error Handler
function handleError(data) {
  const { code, message, details } = data;
  
  console.error(`WebSocket Error [${code}]:`, message, details);
  
  // Show user-friendly error
  showErrorNotification(message);
  
  // Log to error tracking
  trackError({ code, message, details, timestamp: new Date() });
}

// Helper Functions
function addActivityLog(entry) {
  const logContainer = document.getElementById('activity-log');
  if (!logContainer) return;
  
  const logEntry = document.createElement('div');
  logEntry.className = 'log-entry';
  logEntry.innerHTML = `
    <span class="log-time">${new Date(entry.timestamp).toLocaleTimeString()}</span>
    <span class="log-type">${entry.type}</span>
    <span class="log-message">${entry.message}</span>
  `;
  
  logContainer.insertBefore(logEntry, logContainer.firstChild);
  
  // Keep only last 100 entries
  while (logContainer.children.length > 100) {
    logContainer.removeChild(logContainer.lastChild);
  }
}

function updateLastSync(timestamp) {
  const syncEl = document.getElementById('last-sync');
  if (syncEl) {
    syncEl.textContent = `Last sync: ${new Date(timestamp).toLocaleTimeString()}`;
  }
}

function isComponentFile(path) {
  return path.endsWith('.vue') || path.endsWith('.js');
}

function refreshVFSTree() {
  // Trigger VFS tree refresh
  if (window.vfsTree) {
    window.vfsTree.refresh();
  }
}

function reloadComponent(path) {
  // Trigger component hot reload
  window.dispatchEvent(new CustomEvent('componentUpdate', { detail: { path } }));
}

function updateTaskCounters() {
  fetch('/api/queue/stats')
    .then(res => res.json())
    .then(stats => {
      document.getElementById('tasks-pending').textContent = stats.pending || 0;
      document.getElementById('tasks-claimed').textContent = stats.claimed || 0;
      document.getElementById('tasks-completed').textContent = stats.completed || 0;
    });
}

function showErrorNotification(message) {
  const notification = document.createElement('div');
  notification.className = 'error-notification';
  notification.textContent = message;
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.classList.add('fade-out');
    setTimeout(() => notification.remove(), 300);
  }, 5000);
}

function trackError(error) {
  // Send to error tracking service
  if (window.errorTracker) {
    window.errorTracker.log(error);
  }
}

// Export for use in app.js
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { enhancedHandleMessage };
}