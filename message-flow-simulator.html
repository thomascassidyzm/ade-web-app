<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ProjectChat - App Experience Simulator</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://unpkg.com/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/mermaid@10.6.1/dist/mermaid.min.js"></script>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
    .screen-transition {
      transition: all 0.3s ease;
    }
    .message-box {
      animation: messageAppear 0.4s ease;
    }
    @keyframes messageAppear {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body>
  <div id="app"></div>
  
  <script>
    const { createApp, ref, reactive, computed, onMounted } = Vue;
    
    createApp({
      setup() {
        const currentApml = ref(null);
        const selectedScreen = ref('');
        const currentScreenData = ref(null);
        const messageSequence = ref([]);
        const availableScreens = ref([]);
        const userFeedback = ref('');
        const chatHistory = ref([]);
        
        const currentApp = ref('projectchat-app.apml');
        const appScreens = ref([]);
        const screenHistory = ref([]);
        const currentScreenIndex = ref(0);
        const showTechnicalDetails = ref(false);
        const mermaidDiagram = ref('');
        const mermaidElementId = ref('mermaid-diagram');
        
        const loadApp = async (filename) => {
          try {
            const response = await fetch(`/vfs-storage/${filename}`);
            if (!response.ok) throw new Error(`Failed to load ${filename}`);
            const content = await response.text();
            currentApml.value = jsyaml.load(content);
            
            // Extract screens from APML
            if (currentApml.value?.screens) {
              appScreens.value = Object.entries(currentApml.value.screens).map(([key, screen]) => ({
                id: key,
                name: screen.name || key,
                purpose: screen.purpose,
                actions: screen.user_actions || []
              }));
              
              // Load first screen by default
              if (appScreens.value.length > 0) {
                loadScreen(appScreens.value[0]);
              }
              
              // Generate initial Mermaid diagram
              setTimeout(() => updateMermaidDiagram(), 100);
            }
          } catch (error) {
            console.error('Failed to load app:', error);
          }
        };
        
        const loadScreen = (screen) => {
          selectedScreen.value = screen.id;
          currentScreenData.value = screen;
          initializeScreen();
          updateMermaidDiagram();
        };
        
        const initializeScreen = () => {
          messageSequence.value = [];
          
          // Show initial screen load sequence
          messageSequence.value.push({
            type: 'app-to-user',
            content: `Screen loaded: ${currentScreenData.value?.name}`,
            timestamp: Date.now()
          });
        };
        
        const getScreenButtons = () => {
          if (!currentScreenData.value?.actions) return [];
          
          return currentScreenData.value.actions.map((actionObj, index) => ({
            id: `btn-${index}`,
            label: actionObj.action,
            description: actionObj.description,
            action: actionObj.action,
            nextScreen: actionObj.next_screen
          }));
        };
        
        const handleButtonClick = (button) => {
          // Start APML sequence: User ‚Üí App
          messageSequence.value.push({
            type: 'user-to-app',
            content: button.action,
            timestamp: Date.now()
          });
          
          // Trigger App ‚Üí App processes
          setTimeout(() => {
            triggerAppProcesses(button);
          }, 500);
          
          // Show final App ‚Üí User result and screen transition
          setTimeout(() => {
            showAppResponse(button);
            transitionToNextScreen(button);
          }, 1500);
        };
        
        const triggerAppProcesses = (button) => {
          if (!currentApml.value?.patterns?.app_to_app) return;
          
          const processes = currentApml.value.patterns.app_to_app;
          processes.forEach((process, index) => {
            setTimeout(() => {
              messageSequence.value.push({
                type: 'app-to-app',
                content: process,
                timestamp: Date.now()
              });
            }, index * 300);
          });
        };
        
        const showAppResponse = (button) => {
          if (!currentApml.value?.patterns?.app_to_user) return;
          
          const responses = currentApml.value.patterns.app_to_user;
          const contextualResponse = getContextualResponse(button.action, responses);
          
          messageSequence.value.push({
            type: 'app-to-user',
            content: contextualResponse,
            timestamp: Date.now()
          });
        };
        
        const transitionToNextScreen = (button) => {
          if (button.nextScreen) {
            // Find the next screen in appScreens
            const nextScreen = appScreens.value.find(screen => screen.id === button.nextScreen);
            if (nextScreen) {
              // Add screen transition to APML sequence
              messageSequence.value.push({
                type: 'app-to-user',
                content: `Screen transition: Navigate to ${nextScreen.name}`,
                timestamp: Date.now()
              });
              
              // Update screen history
              screenHistory.value.push(currentScreenData.value);
              
              // Transition to next screen
              currentScreenData.value = nextScreen;
              selectedScreen.value = nextScreen.id;
              updateMermaidDiagram();
            }
          }
        };
        
        const goBackToPreviousScreen = () => {
          if (screenHistory.value.length > 0) {
            const previousScreen = screenHistory.value.pop();
            currentScreenData.value = previousScreen;
            selectedScreen.value = previousScreen.id;
            
            messageSequence.value.push({
              type: 'app-to-user',
              content: `Screen transition: Back to ${previousScreen.name}`,
              timestamp: Date.now()
            });
            
            updateMermaidDiagram();
          }
        };
        
        const sendChatMessage = () => {
          if (!userFeedback.value.trim()) return;
          
          chatHistory.value.push({
            type: 'user',
            content: userFeedback.value,
            timestamp: Date.now()
          });
          
          // Simulate ADE response
          setTimeout(() => {
            chatHistory.value.push({
              type: 'ade',
              content: `Thanks for the feedback about: "${userFeedback.value}". I'll incorporate this into the APML validation.`,
              timestamp: Date.now()
            });
          }, 1000);
          
          userFeedback.value = '';
        };
        
        const getContextualResponse = (userAction, appResponses) => {
          // Simple contextual matching
          const action = userAction.toLowerCase();
          
          if (action.includes('describe') || action.includes('requirements')) {
            return appResponses.find(r => r.includes('generated') || r.includes('display')) || appResponses[0];
          }
          
          if (action.includes('select') || action.includes('choose')) {
            return appResponses.find(r => r.includes('status') || r.includes('options')) || appResponses[1];
          }
          
          if (action.includes('deploy') || action.includes('confirm')) {
            return appResponses.find(r => r.includes('deployment') || r.includes('complete')) || appResponses[appResponses.length - 1];
          }
          
          // Default to random response
          return appResponses[Math.floor(Math.random() * appResponses.length)];
        };
        
        const clearMessageSequence = () => {
          messageSequence.value = [];
        };
        
        const resetScreen = () => {
          screenHistory.value = [];
          if (appScreens.value.length > 0) {
            loadScreen(appScreens.value[0]);
          }
        };
        
        const getSequenceStats = () => {
          const userToApp = messageSequence.value.filter(m => m.type === 'user-to-app').length;
          const appToApp = messageSequence.value.filter(m => m.type === 'app-to-app').length;
          const appToUser = messageSequence.value.filter(m => m.type === 'app-to-user').length;
          
          return { userToApp, appToApp, appToUser };
        };
        
        // APML-to-Mermaid Compiler
        const compileApmlToMermaid = () => {
          if (!currentApml.value?.screens) return '';
          
          const screens = currentApml.value.screens;
          let mermaidCode = 'flowchart TD\n';
          
          // Define main screens with special styling
          const mainScreens = ['chat_screen', 'task_screen', 'file_screen', 'team_screen'];
          
          // Add screen nodes
          Object.entries(screens).forEach(([screenId, screen]) => {
            const isMain = mainScreens.includes(screenId);
            const cleanName = screen.name?.replace(' Screen', '') || screenId;
            
            if (isMain) {
              mermaidCode += `    ${screenId}["üè† ${cleanName}"]:::mainScreen\n`;
            } else {
              mermaidCode += `    ${screenId}["${cleanName}"]:::flowScreen\n`;
            }
          });
          
          // Add connections based on next_screen properties
          Object.entries(screens).forEach(([screenId, screen]) => {
            if (screen.user_actions) {
              const connections = new Set(); // Avoid duplicate connections
              
              screen.user_actions.forEach(action => {
                if (action.next_screen && screens[action.next_screen]) {
                  connections.add(action.next_screen);
                }
              });
              
              connections.forEach(nextScreen => {
                mermaidCode += `    ${screenId} --> ${nextScreen}\n`;
              });
            }
          });
          
          // Add styling
          mermaidCode += `
    classDef mainScreen fill:#10b981,stroke:#059669,stroke-width:3px,color:#fff
    classDef flowScreen fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    classDef currentScreen fill:#f59e0b,stroke:#d97706,stroke-width:4px,color:#000
`;
          
          return mermaidCode;
        };
        
        const updateMermaidDiagram = async () => {
          const diagramCode = compileApmlToMermaid();
          if (!diagramCode) return;
          
          // Highlight current screen
          let finalCode = diagramCode;
          if (selectedScreen.value) {
            finalCode += `    class ${selectedScreen.value} currentScreen\n`;
          }
          
          mermaidDiagram.value = finalCode;
          
          // Re-render Mermaid diagram
          setTimeout(async () => {
            const element = document.getElementById(mermaidElementId.value);
            if (element) {
              element.innerHTML = '';
              try {
                const { svg } = await mermaid.render(mermaidElementId.value + '-svg', finalCode);
                element.innerHTML = svg;
              } catch (error) {
                console.error('Mermaid render error:', error);
                element.innerHTML = '<p class="text-red-400 text-sm">Error rendering flow diagram</p>';
              }
            }
          }, 100);
        };
        
        onMounted(() => {
          // Initialize Mermaid
          mermaid.initialize({ theme: 'dark', themeVariables: { primaryColor: '#10b981' } });
          
          // Load ProjectChat app by default
          loadApp('projectchat-app.apml');
        });
        
        return {
          currentApml,
          selectedScreen,
          currentScreenData,
          messageSequence,
          userFeedback,
          chatHistory,
          appScreens,
          screenHistory,
          showTechnicalDetails,
          loadApp,
          loadScreen,
          getScreenButtons,
          handleButtonClick,
          sendChatMessage,
          clearMessageSequence,
          resetScreen,
          getSequenceStats,
          transitionToNextScreen,
          goBackToPreviousScreen
        };
      },
      
      template: `
        <div class="min-h-screen bg-gray-900 text-white">
          <!-- Header -->
          <header class="bg-gray-800 border-b border-gray-700 p-4">
            <div class="flex items-center justify-between">
              <h1 class="text-xl font-bold">üì± ProjectChat</h1>
              <div class="flex items-center space-x-4">
                <div class="text-sm text-gray-300">
                  <span class="font-semibold">{{ currentScreenData?.name || 'Loading...' }}</span>
                </div>
                <button 
                  v-if="screenHistory.length > 0"
                  @click="goBackToPreviousScreen"
                  class="px-3 py-1 bg-green-600 hover:bg-green-700 rounded text-sm"
                >
                  ‚Üê Back
                </button>
                <button 
                  @click="resetScreen"
                  class="px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-sm"
                >
                  üè† Home
                </button>
                <button 
                  @click="showTechnicalDetails = !showTechnicalDetails"
                  :class="[
                    'px-3 py-1 rounded text-sm',
                    showTechnicalDetails ? 'bg-orange-600 hover:bg-orange-700' : 'bg-gray-600 hover:bg-gray-700'
                  ]"
                >
                  {{ showTechnicalDetails ? 'üëÅÔ∏è Hide Tech' : 'üîß Show Tech' }}
                </button>
              </div>
            </div>
          </header>
          
          <div class="flex h-screen">
            <!-- Left Panel: Large Mermaid Diagram + ADE Chat (60%) -->
            <div class="w-3/5 bg-gray-800 border-r border-gray-700 p-4 overflow-y-auto flex flex-col">
              <!-- Large Mermaid Flow Diagram -->
              <div class="flex-1 mb-6">
                <h2 class="text-xl font-semibold mb-4">üó∫Ô∏è App Flow Diagram</h2>
                <div class="h-full p-6 bg-gray-900 rounded-lg border border-gray-600">
                  <div id="mermaid-diagram" class="text-center h-full"></div>
                </div>
              </div>
              
              <!-- ADE Chat Section -->
              <div class="border-t border-gray-700 pt-4">
                <h2 class="text-lg font-semibold mb-4">üí¨ ADE Interaction</h2>
                
                <div class="space-y-2 mb-4 max-h-32 overflow-y-auto">
                  <div
                    v-for="chat in chatHistory"
                    :key="chat.timestamp"
                    :class="[
                      'p-3 rounded text-sm',
                      chat.type === 'user' ? 'bg-green-800 text-green-100' : 'bg-blue-800 text-blue-100'
                    ]"
                  >
                    <div class="font-medium">{{ chat.type === 'user' ? 'You' : 'ADE' }}</div>
                    <div>{{ chat.content }}</div>
                  </div>
                </div>
                
                <div class="flex">
                  <input
                    v-model="userFeedback"
                    @keyup.enter="sendChatMessage"
                    placeholder="How does this feel?"
                    class="flex-1 px-3 py-2 bg-gray-700 border border-gray-600 rounded-l text-sm text-white"
                  />
                  <button
                    @click="sendChatMessage"
                    class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-r text-sm text-white"
                  >
                    Send
                  </button>
                </div>
              </div>
            </div>
            
            <!-- Right Panel: iPhone App + Technical Details (40%) -->
            <div class="w-2/5 bg-gray-900 p-4 overflow-y-auto flex flex-col">
              <!-- iPhone Simulator -->
              <div class="flex items-center justify-center mb-6">
                <div v-if="!currentScreenData" class="text-center text-gray-400">
                  <div class="text-6xl mb-4">üì±</div>
                  <p>Loading ProjectChat...</p>
                </div>
                
                <!-- Real iPhone 12 Size: 390x844px -->
                <div v-else class="bg-black rounded-3xl shadow-2xl" style="width: 390px; height: 844px; position: relative;">
                  <!-- iPhone Frame -->
                  <div class="absolute inset-0 bg-black rounded-3xl p-1">
                    <!-- Screen -->
                    <div class="bg-white rounded-3xl h-full flex flex-col relative overflow-hidden">
                      <!-- Dynamic Island -->
                      <div class="absolute top-2 left-1/2 transform -translate-x-1/2 w-32 h-6 bg-black rounded-full z-10"></div>
                      <!-- Status Bar -->
                      <div class="flex justify-between items-center px-6 py-3 text-sm text-black bg-white">
                        <span class="font-semibold">9:41</span>
                        <div class="flex items-center space-x-1">
                          <div class="w-4 h-2 bg-black rounded-sm"></div>
                          <div class="w-6 h-3 border border-black rounded-sm">
                            <div class="w-full h-full bg-green-500 rounded-sm"></div>
                          </div>
                        </div>
                      </div>
                        
                      <!-- Screen Header -->
                      <div class="px-6 py-4 border-b border-gray-200 bg-white">
                        <div class="flex items-center justify-between">
                          <div>
                            <h3 class="text-xl font-bold text-gray-900">{{ currentScreenData.name }}</h3>
                            <p class="text-sm text-gray-600 mt-1">{{ currentScreenData.purpose }}</p>
                          </div>
                          <div v-if="screenHistory.length > 0">
                            <button 
                              @click="goBackToPreviousScreen"
                              class="text-blue-500 text-lg px-3 py-2 rounded-lg hover:bg-blue-50"
                            >
                              ‚Üê Back
                            </button>
                          </div>
                        </div>
                      </div>
                        
                      <!-- Screen Content -->
                      <div class="flex-1 p-6 overflow-y-auto bg-gray-50">
                        <div class="space-y-4">
                          <button
                            v-for="button in getScreenButtons()"
                            :key="button.id"
                            @click="handleButtonClick(button)"
                            class="w-full p-5 bg-blue-500 hover:bg-blue-600 text-white rounded-xl transition-colors text-left shadow-lg active:scale-95"
                          >
                            <div class="text-base font-semibold">{{ button.label }}</div>
                            <div class="text-sm opacity-90 mt-2">{{ button.description }}</div>
                          </button>
                        </div>
                      </div>
                        
                      <!-- Bottom Navigation (if main screen) -->
                      <div v-if="['chat_screen', 'task_screen', 'file_screen', 'team_screen'].includes(currentScreenData.id)" class="border-t border-gray-200 bg-white px-6 py-4">
                        <div class="flex justify-around">
                          <button 
                            v-for="screen in appScreens.filter(s => ['chat_screen', 'task_screen', 'file_screen', 'team_screen'].includes(s.id))"
                            :key="screen.id"
                            @click="loadScreen(screen)"
                            :class="[
                              'flex flex-col items-center py-3 px-4 rounded-xl text-sm transition-colors',
                              selectedScreen === screen.id 
                                ? 'text-blue-600 bg-blue-50' 
                                : 'text-gray-500 hover:text-gray-700'
                            ]"
                          >
                            <div class="text-2xl mb-2">
                              {{ screen.id === 'chat_screen' ? 'üí¨' : 
                                  screen.id === 'task_screen' ? '‚úÖ' : 
                                  screen.id === 'file_screen' ? 'üìÅ' : 'üë•' }}
                            </div>
                            <div class="font-medium">{{ screen.name.replace(' Screen', '') }}</div>
                          </button>
                        </div>
                      </div>
                      
                      <!-- Home Indicator -->
                      <div class="absolute bottom-2 left-1/2 transform -translate-x-1/2 w-32 h-1 bg-black rounded-full opacity-60"></div>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Technical Details (Collapsible) -->
              <div v-if="showTechnicalDetails" class="border-t border-gray-700 pt-4">
                <h3 class="text-lg font-semibold mb-4">üîß Technical Details</h3>
              
                <div class="space-y-4">
                  <!-- APML Sequence -->
                  <div>
                    <h3 class="text-sm font-medium mb-2 text-orange-400">APML Message Sequence</h3>
                    <div v-if="messageSequence.length > 0" class="space-y-2 max-h-32 overflow-y-auto">
                      <div
                        v-for="message in messageSequence"
                        :key="message.timestamp"
                        :class="[
                          'p-2 rounded text-xs',
                          message.type === 'user-to-app' ? 'bg-green-900 text-green-100' :
                          message.type === 'app-to-app' ? 'bg-purple-900 text-purple-100' :
                          'bg-blue-900 text-blue-100'
                        ]"
                      >
                        <div class="font-medium">{{ message.type.replace('-', ' ‚Üí ').toUpperCase() }}</div>
                        <div>{{ message.content }}</div>
                      </div>
                    </div>
                    <div v-else class="text-center text-gray-400 py-4">
                      <div class="text-xl mb-2">üîÑ</div>
                      <p class="text-xs">Interact with app to see APML sequence</p>
                    </div>
                  </div>
                  
                  <!-- Screen Data -->
                  <div v-if="currentScreenData" class="p-3 bg-gray-700 rounded">
                    <h3 class="text-sm font-medium mb-2 text-blue-400">Current Screen Data</h3>
                    <div class="text-xs text-gray-300 space-y-1">
                      <div><strong>ID:</strong> {{ currentScreenData.id }}</div>
                      <div><strong>Actions:</strong> {{ currentScreenData.actions?.length || 0 }}</div>
                      <div><strong>Purpose:</strong> {{ currentScreenData.purpose }}</div>
                    </div>
                  </div>
                </div>
                
                <div class="mt-4 p-3 bg-gray-900 rounded border border-gray-600">
                  <p class="text-xs text-gray-400">
                    <strong>üéØ For Developers:</strong> This shows the underlying APML processing.
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      `
    }).mount('#app');
  </script>
</body>
</html>